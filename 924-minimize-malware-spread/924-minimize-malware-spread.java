class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n=graph.length;
        
        //here i created a disjoint set and built the graph as per the disjoint set
        DisjointSets dsu=new DisjointSets(n);
        Arrays.sort(initial);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(graph[i][j]==1){
                    dsu.union(i,j);
                }
            }
        }
        //-------------------------------
        
        //this array will store for each node the number of infected nodes present in it
        int numInitInfecNodes[]=new int[n];
        
        //here i calculated the number of infected nodes in each disjoint set
        for(int i=0;i<initial.length;i++){
            int find=dsu.find(initial[i]);
            numInitInfecNodes[find]++;
        }
        
        //-----------------------------------
        
        //finding total malware score
        int totalScore=0;
        HashSet<Integer> set=new HashSet<>();
        for(int i=0;i<initial.length;i++){
            int find=dsu.find(initial[i]);
            set.add(find);
        }
        
        Iterator e=set.iterator();
        while(e.hasNext()){
            int par=(int)e.next();
            totalScore+=dsu.size[par];
        }
        
        //--------------------------------
        
        
        //this pq will store-{nodeRemoved,scoreAfterRemovingIt} in sorted order of conditions
        //specified in the problem statement
        PriorityQueue<int[]> pq=new
            PriorityQueue<>((a,b)->(a[1]==b[1]?a[0]-b[0]:a[1]-b[1]));
        
        //--------------------------------------------
        
        //it's clear that we can only remove a single node, so we will just look at those sets
        //in which the number of initially infected nodes is 1 because then only the infection
        //can be stopped otherwise it will spread regardless.
        for(int i=0;i<initial.length;i++){
            int find=dsu.find(initial[i]);
            if(numInitInfecNodes[find]==1){
                int currScore=totalScore-dsu.size[find];
                pq.offer(new int[]{initial[i],currScore});
            }
        }
        
        if(pq.isEmpty()) return initial[0];
        return pq.peek()[0];
        
    }
}

class DisjointSets{
    int parent[];
    int size[];
    
    public DisjointSets(int n){
        parent=new int[n];
        size=new int[n];
        Arrays.fill(size,1);
        for(int i=0;i<n;i++) parent[i]=i;
    }
    
    public int find(int node){
        if(parent[node]==node) return node;
        return parent[node]=find(parent[node]);
    }
    
    public void union(int u,int v){
        int pu=find(u);
        int pv=find(v);
        
        if(pu==pv) return;
        
        if(size[pu]<=size[pv]){
            size[pv]+=size[pu];
            parent[pu]=pv;
        }else{
            size[pu]+=size[pv];
            parent[pv]=pu;
        }
    }
}